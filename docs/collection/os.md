# 操作系统

计算机系统由硬件和软件两部分组成，操作系统（OS）是配置在计算机硬件上的第一层软件。操作系统自诞生起就为以下目标服务

1. 提高系统的资源利用率
2. 提高系统的吞吐量
3. 高效便携的管理硬件、软件资源
4. 提高系统的可扩充性

操作系统经过多年发展，目前形成了规范的基础原理，其作用主要体现在以下方面

- OS作为用户与计算机硬件系统之间的接口
  - 处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统
  - 用户可以通过三种方式与操作系统交互
    - 命令方式
    - 系统调用方式API
    - 图形、窗口界面
- OS作为计算机系统资源的管理者
  - 处理器、存储器、I/O设备及信息管理
  - 计算机系统资源管理者
- OS实现对计算机资源的抽象管理

## 操作系统的基本特性

并发、共享、虚拟和异步

### 并发性

#### 并行和并发

- 并行性是指两个或多个事件在同一时刻发生，真正的同时进行
- 并发性是指两个或多个事件在同一时间间隔内发生，宏观上同时执行，微观上交替执行

#### 进程

操作系统引入进程的目的，是为了使多个程序能并发执行。

进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。

一个进程在运行时需要一定的资源，如 CPU、存储空间及 I/O 设备等

#### 线程

为了减小因为进程的启用而产生的开销过大问题，引入线程。

在引入线程的 OS 中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。

### 共享性

指系统中的资源可供内存中多个并发执行的线程共同使用。资源共享的方式如下

#### 互斥共享

同一时刻内仅允许一个进程（线程）使用。

#### 同时访问

允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。

### 虚拟技术

指通过某种技术把一个物理实体变为若干个逻辑上的对应物。物理实体(前者)是实的，即实际存在的，而后者是虚的，仅是用户感觉上的东西。相应地，用于实现虚拟的技术称为虚拟技术。在操作系统中利用了两种方式实现虚拟技术，即**时分复用技术和空分复用技术**。

#### 时分复用技术

分时使用方式

##### 虚拟处理机技术

在虚拟处理机技术中，利用多道程序设计技术，为每道程序建立一个进程，让多道程序并发地执行，以此来分时使用一台处理机。此时，虽然系统中只有一台处理机，但它却能同时为多个用户服务，使每个终端用户都认为是有一个处理机在专门为他服务。

##### 虚拟设备技术

我们还可以通过虚拟设备技术，将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，这样便可使原来仅允许在一段时间内由一个用户访问的设备(即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。

#### 空分复用技术

对空间资源进行分割进行处理

##### 虚拟磁盘技术

将一个硬盘通过分割，虚拟为多个虚拟磁盘技术。

##### 虚拟存储器技术

在单道程序环境下，处理机会有很多空闲时间，内存也会有很多空闲空间，显然，这会使处理机和内存的效率低下。如果说时分复用技术是利用处理机的空闲时间来运行其它的程序，使处理机的利用率得以提高，那么空分复用则是利用存储器的空闲空间来存放其它的程序，以提高内存的利用率。

### 异步性

在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。

## 操作系统的主要功能

操作系统的主要任务，是为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率和方便用户的使用。

### 进程管理功能

主要功能是创建和撤消进程(线程)，对诸进程(线程)的运行进行协调，实现进程(线程)之间的信息交换，以及按照一定的算法把处理机分配给进程(线程)。

#### 进程控制

能够进行创建进程、撤销已结束进程以及控制进程在不同的状态中进行切换

#### 进程同步

- 进程互斥方式。这是指诸进程(线程)在对临界资源进行访问时，应采用互斥方式；
- 进程同步方式。这是指在相互合作去完成共同任务的诸进程(线程)间，由同步机构对它们的执行次序加以协调。

#### 进程通信

不同的进程线程之间进行信息的交换

#### 调度

- 作业调度
- 进程调度

### 内存管理功能

#### 内存分配

- 内存分配数据结构。该结构用于记录内存空间的使用情况，作为内存分配的依据；
-  内存分配功能。系统按照一定的内存分配算法为用户程序分配内存空间；
-  内存回收功能。系统对于用户不再需要的内存，通过用户的释放请求去完成系统的
  回收功能。

#### 内存保护

内存保护的主要任务是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰；绝不允许用户程序访问操作系统的程序和数据；也不允许用户程序转移到非共享的其它用户程序中去执行

#### 地址映射

逻辑地址映射到物理地址，以获得相应的支持

#### 内存扩充

借助于虚拟存储技术，从逻辑上去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多

### 设备管理功能

完成用户进程提出的 I/O 请求；为用户进程分配其所需的 I/O 设备；提高 CPU 和 I/O 设备的利用率；提高 I/O 速度；方便用户使用 I/O 设备。为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。

### 文件管理功能

文件管理应具有对文件存储空间的管理、目录管理、文件的读/写管理，以及文件的共享与保护等功能

## 操作系统结构设计

操作系统的结构设计，从传统结构到现代结构不断发展，传统的结构诸如无结构OS、模块化结构OS、分层式结构OS等，现代的操作系统则为微内核OS。

### 微内核OS结构

- 内核足够小
  - 实现与硬件紧密相关的处理
  - 实现一些比较基本的功能
  - 负责客户和服务器之间的通信
- 基于客户/服务器模式
  - 即用户态和内核态的交互机制
- 采用机制与策略分离原则
- 采用面向对象技术

### 微内核的优势

- 系统的高可拓展性
- 提高了系统的可靠性
- 可移植性
- 对分布式系统的支持
- 面向对象技术的融入

## 程序是如何执行的？

>  [程序在计算机中是如何运行的？](https://zhuanlan.zhihu.com/p/444921780) 

通常，应用程序可以被分成若干个程序段，在各程序段之间，必须安装某种先后顺序执行。

程序执行具有以下特征

1. 顺序性：处理机的操作严格安装程序规定的顺序执行，每个操作必须在上一个操作结束后开始。
2. 封闭性：程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。
3. 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。

## 前趋图及其功能

 通常用于表现事务之间先后顺序的制约关系 

### 概念

前趋图是一个有向无循环图

<img :src="$withBase('/imags/1653374810974.png')" alt="1653374810974">



- 没有前趋的结点称为初始结点
- 没有后继的结点称为终止结点

### 功能

- 用于描述进程之间相关执行的前后关系，图中的每个节点都描述一个程序段或进程。
- 结点之间的有向边则用于表示两个结点之间的偏序关系。
- 对于没有有向边联系的结点可以并发执行

## 进程的特征及状态

为了解决程序在执行过程中，存在的间断性、不可再现性等特征，引入进程的概念，以便于程序的并发执行。进程是对资源进行空间划分的一种方式

### 进程的特征

#### 结构性

进程映像：通常的程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制块，即 PCB(Process Control Block)；而由程序段、相关的数据段和 PCB 三部分便构成了进程实体。

#### 动态性

进程具有生命周期，即可以被创建、执行、调度、阻塞、销毁

#### 并发性

多个进程同时存在于内存中，同时运行

#### 独立性

进程实体能够独立运行、独立分配资源、独立接受调度

#### 异步性

进程按异步的方式进行

<img :src="$withBase('/imags/1653375808732.png')" alt="1653375808732">

### 进程的状态

- 创建态
  - 创建一个新进程时需要创建PCB
  - 将该进程插入就绪队列中
- 终止态
  - 销毁进程
- 就绪态
  - 进程被分配必要资源，仅需获得CPU后，就可以立即执行
  - 就绪态的进程通常存在于就绪队列中
- 执行态
  - 进程获得CPU后，执行相应的作业
- 阻塞态
  - 正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态
- 挂起态
  - 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我
    们把这种静止状态称为挂起状态。
  - 父进程请求。有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。
  -  负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
  - 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情
    况或进行记账。

<img :src="$withBase('/imags/1653375999165.png')" alt="1653375999165">

## 进程在OS中如何被管理？

### 进程的控制块

进程的控制块是为了描述和控制进程的运行，系统为每个进程定义的一个数据结构，即进程控制块PCB，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。

PCB是进程存在的唯一标记。

### 进程控制块信息

- 进程标识符
  - 内部标识符，进程的序号，是每个进程的唯一标记
  - 外部标识符，创建者提供
- 处理机状态
  - 通用寄存器
  - 指令计数器
  - 程序状态字
  - 用户栈指针
- 进程调度信息
  - 进程状态
  - 进程优先级
  - 进程执行时间等
  - 事件
- 进程控制信息
  - 程序和数据的地址
  - 进程同步和通信机制
  - 资源清单
  - 链接指针

### 进程控制块的组织方式

#### 链接方式

这是把具有同一状态的 PCB，用其中的链接字链接成一个队列，对其中的就绪队列常按进程优先级的高低排列，把优先级高的进程的 PCB 排在
队列前面

<img :src="$withBase('/imags/1653376482956.png')" alt="1653376482956">

#### 索引方式

系统根据所有进程的状态建立几张索引表。例如，就绪索引表、阻塞索引表等

<img :src="$withBase('/imags/1653376498771.png')" alt="1653376498771">

## 如何控制进程？

如何控制进程的创建、终止、阻塞、挂起？

### 原子操作

所谓原子操作，是指一个操作中的所有动作，要么全做，要么全不做，即一个操作中的所有动作是一个不可分割的操作单元。

### 进程图

为了描述进程之间的关系，引入了进程图的概念。

<img :src="$withBase('/imags/1653377399822.png')" alt="1653377399822">

- 图中的结点(圆圈)代表进程。在进程 D 创建了进程 I 之后，称 D 是 I 的父进程(Parent Process)，I 是 D 的子进程(Progeny Process)
- 图中的有向边用来描述父子关系
- A被称为根进程

### 进程的创建

#### 进程的创建过程

1. 申请PCB，为新进程获得唯一的数字标识符
2. 为新进程分配资源
3. 初始化进程控制块
4. 将进程插入就绪队列

### 进程的终止

#### 进程的终止过程

1. 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态
2. 若被终止进程处于执行状态，立即终止该进程的执行，并设置调度标志为真
3. 若该进程还有子孙进程，还应将所有子孙进程终止
4. 将被终止进程拥有的资源归还父进程
5. 将被终止进程PCB从所在队列移除

### 进程的阻塞与唤醒

#### 进程阻塞过程

进程便通过调用阻塞原语 block 把自己阻塞

如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。最后，转调度程序进行重新调度，将处理机分配给另一就绪进程并进行切换，亦即，保留被阻塞进程的处理机状态(在 PCB 中)，再按新进程的 PCB 中的处理机状态设置 CPU 的环境。

#### 进程唤醒过程

当被阻塞进程所期待的事件出现时，如 I/O 完成或其所期待的数据已经到达，则由有关进程(比如用完并释放了该 I/O 设备的进程)调用唤醒原语 wakeup( )，将等待该事件的进程唤起

## 进程为什么要实现同步？

操作系统引入进程概念，能够提高资源的利用率和系统的吞吐量，但是，因为进程之间的异步性，在争夺临界资源时，如果进程无序、混乱，则容易使进程间出错。

这种出错的关系，总的来说可以归为两类：

1. 直接制约关系，如果A进程的程序输入，需要B进程的输出，则A进程只能等B进程完成后进行
2. 间接制约关系，如果A和B进程都需要使用计算机系统的某个资源，但二者不能同时使用，这个时候就产生了制约关系

进程间的制约关系，要求进程必须实现对计算机资源的有序调用，因此需要进行进程的同步。

### 临界资源

被不同的进程同时需要，但又需要进程间互斥异步的共享的资源，称为临界资源。

**如著名的生产-消费者问题**

> 有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有 n 个缓冲区的缓冲池，生产者进程将它所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步，即不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。

进程中访问临界资源的代码片段称为临界区。

## 如何实现进程同步？

### 信号量机制



### 管程机制

## 进程间通信有哪些类型？

### 共享存储器系统

相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信.

1. 基于共享数据结构的通信方式，进程共用某些数据结构，实现进程间信息交换。
2. 基于共享存储区的通信方式，在存储器中划出了一块共享存储
   区，诸进程可通过对共享存储区中数据的读或写来实现通信。

### 消息传递系统

进程间的数据交换是以格式化的消息(message)为单位的。

### 管道通信

所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件。

1. 互斥，当一个进程郑总对pipe执行读写操作时，其它程序必须等待
2. 同步，当写进程把一定数量的数据写入pipe时，就区睡眠等待，直到输出程序拿到数据，将其唤醒。

## 为什么要有线程？

1. 线程是进程的最小执行单位，引入线程能够使得系统消耗更小
2. 以小的开销完成系统的并行任务

## 线程和进程有哪些异同？

1. 调度
   1. 线程是调度和分配任务的基本单位，进程是资源使用的最小单位
   2. 线程和进程都能够实现并发任务，但线程是进程的一个实例
   3. 线程的切换会引起进程的切换
2. 并发性
   1. 线程和进程都可以进行并发处理
   2. 一个进程程序可以通过线程设置多个线程任务
3. 拥有资源
   1. 进程拥有资源，线程不拥有资源
   2. 线程只能访问隶属的进程的资源
4. 系统开销
   1. 进程对于系统的开销高于线程
   2. 同步与通信方面线程比进程容易

## 线程间如何实现通信？

1. 互斥锁
2. 条件变量
3. 信号量

## 线程在OS中是如何实现的？

### 内核支持线程KST(Kernel supported threads)

- 内核支持线程同进程一样都是在内核支持下运行的, 与内核密切相关
- 创建, 阻塞, 撤销, 切换都是在内核空间实现的
- 内核空间中为每一个线程设置了一个线程控制块, 内核通过线程控制块对其进行控制

#### 优点

在多处理器系统中内核可以同时调度同一进程中的多个线程并发执行
如果进程中的一个线程阻塞了, 内核可继续调度该进程中的其他线程

#### 缺点

同一进程中切换线程开销较大, 因为要经历用户态, 内核态的切换

### 用户级线程ULT(User level threads)

- 用户级线程与内核无关
- 创建, 撤销, 同步和通信等功能都是在用户空间中实现的.
- 调度以进程为单位

#### 优点

线程切换不需要转换内核状态, 节省了切换的开销
不同的进程可根据自身选择不同的调度算法
用户级线程的实现与OS平台无关

#### 缺点

当一个线程阻塞时, 其他所有的线程都被阻塞
不能利用多处理机的优点

### 组合方式

- 将以上两种线程的方式结合, 形成组合方式线程.
- 组合方式线程支持多个内核支持线程和用户级线程的建立, 调度和管理.
- 结合上述两种线程的优点, 形成了三种不同的模型

1. #### 多对一模型

  将用户线程映射到一个内核控制线程, 当用户线程需要访问内核时, 将其映射到一个内核线程, 但每次只允许一个线程进行映射.主要的优点是开销小, 效率高, 缺点在于一个线程在访问内核时发生阻塞, 则整个进程都会被阻塞. 且同一时刻只有一个线程可以访问内核

2. #### 一对一模型

  每一个用户级线程都映射到一个内核控制线程. 主要的优点是当一个线程阻塞, 允许其他线程继续运行. 且允许多个线程并行地运行在多处理机系统上. 缺点是开销较大

3. #### 多对多模型

将多个用户线程映射到同样数量或者更少数量的内核线程上,可以根据实际情况调整内核控制线程数目, 结合了上述两种模型的优点.

什么是操作系统的处理机调度？

当多道程序环境下，内存中含有多个进程的时候，进程的数目多于处理机的数目，就要求对进程的执行根据某种算法，让处理机动态的执行任务。

分配处理机的任务是处理机调度程序完成的，因此可称为处理机调度。

处理机调度程序处理作业时，往往经历多个过程，作业才能被进程执行

1. 高级调度
2. 中级调度
3. 低级调度

## 什么是死锁？

多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，所有的进程都将无法继续。

## 死锁是如何产生的？

### 竞争资源

当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以
满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。

### 程间推进顺序非法

进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁

## 产生死锁需要哪些条件？

- **互斥条件**：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。
- **请求和保持条件**：指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
- **不剥夺条件**：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- **环路等待条件**：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P 0 ，P 1 ，P 2 ，…，P n }中的 P 0 正在等待一个 P 1 占用的资源； P 1 正在等待 P 2 占用的资源，……，P n 正在等待已被 P 0 占用的资源。

## 怎么处理死锁？

- 预防死锁
- 避免死锁
- 监测死锁
- 解除死锁