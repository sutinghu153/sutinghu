# 操作系统

计算机系统由硬件和软件两部分组成，操作系统（OS）是配置在计算机硬件上的第一层软件。操作系统自诞生起就为以下目标服务

1. 提高系统的资源利用率
2. 提高系统的吞吐量
3. 高效便携的管理硬件、软件资源
4. 提高系统的可扩充性

操作系统经过多年发展，目前形成了规范的基础原理，其作用主要体现在以下方面

- OS作为用户与计算机硬件系统之间的接口
  - 处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统
  - 用户可以通过三种方式与操作系统交互
    - 命令方式
    - 系统调用方式API
    - 图形、窗口界面
- OS作为计算机系统资源的管理者
  - 处理器、存储器、I/O设备及信息管理
  - 计算机系统资源管理者
- OS实现对计算机资源的抽象管理

## 操作系统的基本特性

并发、共享、虚拟和异步

### 并发性

#### 并行和并发

- 并行性是指两个或多个事件在同一时刻发生，真正的同时进行
- 并发性是指两个或多个事件在同一时间间隔内发生，宏观上同时执行，微观上交替执行

#### 进程

操作系统引入进程的目的，是为了使多个程序能并发执行。

进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。

一个进程在运行时需要一定的资源，如 CPU、存储空间及 I/O 设备等

#### 线程

为了减小因为进程的启用而产生的开销过大问题，引入线程。

在引入线程的 OS 中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。

### 共享性

指系统中的资源可供内存中多个并发执行的线程共同使用。资源共享的方式如下

#### 互斥共享

同一时刻内仅允许一个进程（线程）使用。

#### 同时访问

允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。

### 虚拟技术

指通过某种技术把一个物理实体变为若干个逻辑上的对应物。物理实体(前者)是实的，即实际存在的，而后者是虚的，仅是用户感觉上的东西。相应地，用于实现虚拟的技术称为虚拟技术。在操作系统中利用了两种方式实现虚拟技术，即**时分复用技术和空分复用技术**。

#### 时分复用技术

分时使用方式

##### 虚拟处理机技术

在虚拟处理机技术中，利用多道程序设计技术，为每道程序建立一个进程，让多道程序并发地执行，以此来分时使用一台处理机。此时，虽然系统中只有一台处理机，但它却能同时为多个用户服务，使每个终端用户都认为是有一个处理机在专门为他服务。

##### 虚拟设备技术

我们还可以通过虚拟设备技术，将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备，这样便可使原来仅允许在一段时间内由一个用户访问的设备(即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。

#### 空分复用技术

对空间资源进行分割进行处理

##### 虚拟磁盘技术

将一个硬盘通过分割，虚拟为多个虚拟磁盘技术。

##### 虚拟存储器技术

在单道程序环境下，处理机会有很多空闲时间，内存也会有很多空闲空间，显然，这会使处理机和内存的效率低下。如果说时分复用技术是利用处理机的空闲时间来运行其它的程序，使处理机的利用率得以提高，那么空分复用则是利用存储器的空闲空间来存放其它的程序，以提高内存的利用率。

### 异步性

在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。

## 操作系统的主要功能

操作系统的主要任务，是为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率和方便用户的使用。

### 进程管理功能

主要功能是创建和撤消进程(线程)，对诸进程(线程)的运行进行协调，实现进程(线程)之间的信息交换，以及按照一定的算法把处理机分配给进程(线程)。

#### 进程控制

能够进行创建进程、撤销已结束进程以及控制进程在不同的状态中进行切换

#### 进程同步

- 进程互斥方式。这是指诸进程(线程)在对临界资源进行访问时，应采用互斥方式；
- 进程同步方式。这是指在相互合作去完成共同任务的诸进程(线程)间，由同步机构对它们的执行次序加以协调。

#### 进程通信

不同的进程线程之间进行信息的交换

#### 调度

- 作业调度
- 进程调度

### 内存管理功能

#### 内存分配

- 内存分配数据结构。该结构用于记录内存空间的使用情况，作为内存分配的依据；
-  内存分配功能。系统按照一定的内存分配算法为用户程序分配内存空间；
-  内存回收功能。系统对于用户不再需要的内存，通过用户的释放请求去完成系统的
  回收功能。

#### 内存保护

内存保护的主要任务是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰；绝不允许用户程序访问操作系统的程序和数据；也不允许用户程序转移到非共享的其它用户程序中去执行

#### 地址映射

逻辑地址映射到物理地址，以获得相应的支持

#### 内存扩充

借助于虚拟存储技术，从逻辑上去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多

### 设备管理功能

完成用户进程提出的 I/O 请求；为用户进程分配其所需的 I/O 设备；提高 CPU 和 I/O 设备的利用率；提高 I/O 速度；方便用户使用 I/O 设备。为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。

### 文件管理功能

文件管理应具有对文件存储空间的管理、目录管理、文件的读/写管理，以及文件的共享与保护等功能

## 操作系统结构设计

操作系统的结构设计，从传统结构到现代结构不断发展，传统的结构诸如无结构OS、模块化结构OS、分层式结构OS等，现代的操作系统则为微内核OS。

### 微内核OS结构

- 内核足够小
  - 实现与硬件紧密相关的处理
  - 实现一些比较基本的功能
  - 负责客户和服务器之间的通信
- 基于客户/服务器模式
  - 即用户态和内核态的交互机制
- 采用机制与策略分离原则
- 采用面向对象技术

### 微内核的优势

- 系统的高可拓展性
- 提高了系统的可靠性
- 可移植性
- 对分布式系统的支持
- 面向对象技术的融入

## 程序是如何执行的？

>  [程序在计算机中是如何运行的？](https://zhuanlan.zhihu.com/p/444921780) 

通常，应用程序可以被分成若干个程序段，在各程序段之间，必须安装某种先后顺序执行。

程序执行具有以下特征

1. 顺序性：处理机的操作严格安装程序规定的顺序执行，每个操作必须在上一个操作结束后开始。
2. 封闭性：程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。
3. 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。

## 前趋图及其功能

 通常用于表现事务之间先后顺序的制约关系 

### 概念

前趋图是一个有向无循环图

<img :src="$withBase('/imags/1653374810974.png')" alt="1653374810974">



- 没有前趋的结点称为初始结点
- 没有后继的结点称为终止结点

### 功能

- 用于描述进程之间相关执行的前后关系，图中的每个节点都描述一个程序段或进程。
- 结点之间的有向边则用于表示两个结点之间的偏序关系。
- 对于没有有向边联系的结点可以并发执行

## 进程的特征及状态

为了解决程序在执行过程中，存在的间断性、不可再现性等特征，引入进程的概念，以便于程序的并发执行。进程是对资源进行空间划分的一种方式

### 进程的特征

#### 结构性

进程映像：通常的程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制块，即 PCB(Process Control Block)；而由程序段、相关的数据段和 PCB 三部分便构成了进程实体。

#### 动态性

进程具有生命周期，即可以被创建、执行、调度、阻塞、销毁

#### 并发性

多个进程同时存在于内存中，同时运行

#### 独立性

进程实体能够独立运行、独立分配资源、独立接受调度

#### 异步性

进程按异步的方式进行

<img :src="$withBase('/imags/1653375808732.png')" alt="1653375808732">

### 进程的状态

- 创建态
  - 创建一个新进程时需要创建PCB
  - 将该进程插入就绪队列中
- 终止态
  - 销毁进程
- 就绪态
  - 进程被分配必要资源，仅需获得CPU后，就可以立即执行
  - 就绪态的进程通常存在于就绪队列中
- 执行态
  - 进程获得CPU后，执行相应的作业
- 阻塞态
  - 正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态
- 挂起态
  - 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我
    们把这种静止状态称为挂起状态。
  - 父进程请求。有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。
  -  负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
  - 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情
    况或进行记账。

<img :src="$withBase('/imags/1653375999165.png')" alt="1653375999165">

## 进程在OS中如何被管理？

### 进程的控制块

进程的控制块是为了描述和控制进程的运行，系统为每个进程定义的一个数据结构，即进程控制块PCB，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。

PCB是进程存在的唯一标记。

### 进程控制块信息

- 进程标识符
  - 内部标识符，进程的序号，是每个进程的唯一标记
  - 外部标识符，创建者提供
- 处理机状态
  - 通用寄存器
  - 指令计数器
  - 程序状态字
  - 用户栈指针
- 进程调度信息
  - 进程状态
  - 进程优先级
  - 进程执行时间等
  - 事件
- 进程控制信息
  - 程序和数据的地址
  - 进程同步和通信机制
  - 资源清单
  - 链接指针

### 进程控制块的组织方式

#### 链接方式

这是把具有同一状态的 PCB，用其中的链接字链接成一个队列，对其中的就绪队列常按进程优先级的高低排列，把优先级高的进程的 PCB 排在
队列前面

<img :src="$withBase('/imags/1653376482956.png')" alt="1653376482956">

#### 索引方式

系统根据所有进程的状态建立几张索引表。例如，就绪索引表、阻塞索引表等

<img :src="$withBase('/imags/1653376498771.png')" alt="1653376498771">

## 如何控制进程？

如何控制进程的创建、终止、阻塞、挂起？

### 原子操作

所谓原子操作，是指一个操作中的所有动作，要么全做，要么全不做，即一个操作中的所有动作是一个不可分割的操作单元。

### 进程图

为了描述进程之间的关系，引入了进程图的概念。

<img :src="$withBase('/imags/1653377399822.png')" alt="1653377399822">

- 图中的结点(圆圈)代表进程。在进程 D 创建了进程 I 之后，称 D 是 I 的父进程(Parent Process)，I 是 D 的子进程(Progeny Process)
- 图中的有向边用来描述父子关系
- A被称为根进程

### 进程的创建

#### 进程的创建过程

1. 申请PCB，为新进程获得唯一的数字标识符
2. 为新进程分配资源
3. 初始化进程控制块
4. 将进程插入就绪队列

### 进程的终止

#### 进程的终止过程

1. 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态
2. 若被终止进程处于执行状态，立即终止该进程的执行，并设置调度标志为真
3. 若该进程还有子孙进程，还应将所有子孙进程终止
4. 将被终止进程拥有的资源归还父进程
5. 将被终止进程PCB从所在队列移除

### 进程的阻塞与唤醒

#### 进程阻塞过程

进程便通过调用阻塞原语 block 把自己阻塞

如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。最后，转调度程序进行重新调度，将处理机分配给另一就绪进程并进行切换，亦即，保留被阻塞进程的处理机状态(在 PCB 中)，再按新进程的 PCB 中的处理机状态设置 CPU 的环境。

#### 进程唤醒过程

当被阻塞进程所期待的事件出现时，如 I/O 完成或其所期待的数据已经到达，则由有关进程(比如用完并释放了该 I/O 设备的进程)调用唤醒原语 wakeup( )，将等待该事件的进程唤起

## 进程为什么要实现同步？

操作系统引入进程概念，能够提高资源的利用率和系统的吞吐量，但是，因为进程之间的异步性，在争夺临界资源时，如果进程无序、混乱，则容易使进程间出错。

这种出错的关系，总的来说可以归为两类：

1. 直接制约关系，如果A进程的程序输入，需要B进程的输出，则A进程只能等B进程完成后进行
2. 间接制约关系，如果A和B进程都需要使用计算机系统的某个资源，但二者不能同时使用，这个时候就产生了制约关系

进程间的制约关系，要求进程必须实现对计算机资源的有序调用，因此需要进行进程的同步。

### 临界资源

被不同的进程同时需要，但又需要进程间互斥异步的共享的资源，称为临界资源。

**如著名的生产-消费者问题**

> 有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有 n 个缓冲区的缓冲池，生产者进程将它所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步，即不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。

进程中访问临界资源的代码片段称为临界区。

## 如何实现进程同步？

### 信号量机制



### 管程机制

## 进程间通信有哪些类型？

### 共享存储器系统

相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信.

1. 基于共享数据结构的通信方式，进程共用某些数据结构，实现进程间信息交换。
2. 基于共享存储区的通信方式，在存储器中划出了一块共享存储
   区，诸进程可通过对共享存储区中数据的读或写来实现通信。

### 消息传递系统

进程间的数据交换是以格式化的消息(message)为单位的。

### 管道通信

所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件。

1. 互斥，当一个进程郑总对pipe执行读写操作时，其它程序必须等待
2. 同步，当写进程把一定数量的数据写入pipe时，就区睡眠等待，直到输出程序拿到数据，将其唤醒。

## 为什么要有线程？

1. 线程是进程的最小执行单位，引入线程能够使得系统消耗更小
2. 以小的开销完成系统的并行任务

## 线程和进程有哪些异同？

1. 调度
   1. 线程是调度和分配任务的基本单位，进程是资源使用的最小单位
   2. 线程和进程都能够实现并发任务，但线程是进程的一个实例
   3. 线程的切换会引起进程的切换
2. 并发性
   1. 线程和进程都可以进行并发处理
   2. 一个进程程序可以通过线程设置多个线程任务
3. 拥有资源
   1. 进程拥有资源，线程不拥有资源
   2. 线程只能访问隶属的进程的资源
4. 系统开销
   1. 进程对于系统的开销高于线程
   2. 同步与通信方面线程比进程容易

## 线程间如何实现通信？

1. 互斥锁
2. 条件变量
3. 信号量

## 线程在OS中是如何实现的？

### 内核支持线程KST(Kernel supported threads)

- 内核支持线程同进程一样都是在内核支持下运行的, 与内核密切相关
- 创建, 阻塞, 撤销, 切换都是在内核空间实现的
- 内核空间中为每一个线程设置了一个线程控制块, 内核通过线程控制块对其进行控制

#### 优点

在多处理器系统中内核可以同时调度同一进程中的多个线程并发执行
如果进程中的一个线程阻塞了, 内核可继续调度该进程中的其他线程

#### 缺点

同一进程中切换线程开销较大, 因为要经历用户态, 内核态的切换

### 用户级线程ULT(User level threads)

- 用户级线程与内核无关
- 创建, 撤销, 同步和通信等功能都是在用户空间中实现的.
- 调度以进程为单位

#### 优点

线程切换不需要转换内核状态, 节省了切换的开销
不同的进程可根据自身选择不同的调度算法
用户级线程的实现与OS平台无关

#### 缺点

当一个线程阻塞时, 其他所有的线程都被阻塞
不能利用多处理机的优点

### 组合方式

- 将以上两种线程的方式结合, 形成组合方式线程.
- 组合方式线程支持多个内核支持线程和用户级线程的建立, 调度和管理.
- 结合上述两种线程的优点, 形成了三种不同的模型

1. #### 多对一模型

  将用户线程映射到一个内核控制线程, 当用户线程需要访问内核时, 将其映射到一个内核线程, 但每次只允许一个线程进行映射.主要的优点是开销小, 效率高, 缺点在于一个线程在访问内核时发生阻塞, 则整个进程都会被阻塞. 且同一时刻只有一个线程可以访问内核

2. #### 一对一模型

  每一个用户级线程都映射到一个内核控制线程. 主要的优点是当一个线程阻塞, 允许其他线程继续运行. 且允许多个线程并行地运行在多处理机系统上. 缺点是开销较大

3. #### 多对多模型

将多个用户线程映射到同样数量或者更少数量的内核线程上,可以根据实际情况调整内核控制线程数目, 结合了上述两种模型的优点.

什么是操作系统的处理机调度？

当多道程序环境下，内存中含有多个进程的时候，进程的数目多于处理机的数目，就要求对进程的执行根据某种算法，让处理机动态的执行任务。

分配处理机的任务是处理机调度程序完成的，因此可称为处理机调度。

处理机调度程序处理作业时，往往经历多个过程，作业才能被进程执行

1. 高级调度
2. 中级调度
3. 低级调度

## 什么是死锁？

多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，所有的进程都将无法继续。

## 死锁是如何产生的？

### 竞争资源

当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以
满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。

### 程间推进顺序非法

进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁

## 产生死锁需要哪些条件？

- **互斥条件**：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。
- **请求和保持条件**：指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
- **不剥夺条件**：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- **环路等待条件**：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P 0 ，P 1 ，P 2 ，…，P n }中的 P 0 正在等待一个 P 1 占用的资源； P 1 正在等待 P 2 占用的资源，……，P n 正在等待已被 P 0 占用的资源。

## 怎么处理死锁？

- 预防死锁
- 避免死锁
- 监测死锁
- 解除死锁

## 存储器包括哪些结构？

存储器管理的主要对象是内存。一般采用层次结构来组织

> 高层  CPU 寄存器
>
> > 由于主存储器的访问速度远低于 CPU 执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器
>
> 中间 主存
>
> > 高速缓存
> >
> > > 将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度
> > >
> > > 当 CPU 访问一组特定信息时，首先检查它是否在高速缓存中，如果已存在，可直接从中取出使用
> >
> > 主存储器
> >
> > > 用于保存进程运行时的程序和数据，也称可执行存储器
> > >
> > > CPU的控制部件只能从主存储器中取得指令和数据，数据能够从主存储器读取并将它们装入到
> > > 寄存器中，或者从寄存器存入到主存储器
> >
> > 磁盘缓存
> >
> > > 由于目前磁盘的 I/O 速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数
>
> 底层 辅存
>
> > 磁盘
> >
> > 可移动存储介质

## OS如何连续为程序分配内存空间？

连续分配方式：为一个用户分配一个连续的内存空间

### 单一连续分配

只能用于单任务、单用户的操作系统

#### 特点

- 内存被分为系统区和用户区
- 系统区仅提供给OS使用，通常在内存的低址部分
- 用户区是指除系统区以外的全部内存空间，提供给用户使用

### 固定分区分配

固定分区式分配是最简单的一种可运行多道程序的存储管理方式。

这是将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行。

#### 特点

- 根据分区的方式，可以分为分区大小相等的分区、分区大小不等的分区
- 内存分配时，往往需要建立分区使用表
  - 将分区大小进行排队
  - 各表项包括每个分区的起始地址、大小和状态

### 动态分区分配

在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作的问题

#### 分区分配中的数据结构

- 空闲分区表，包括分区序号、分区始址及分区的大小等数据项
- 空闲分区链，为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链
  - <img :src="$withBase('/imags/1653898559591.png')" alt="1653898559591">

#### 内存的分配

<img :src="$withBase('/imags/1653898646048.png')" alt="1653898646048">

> 请求的分区大小为   **u.size**
>
> 每个空闲分区的大小可表示为 **m.size**
>
>  m.size-u.size≤size  (size 是事先规定的不再切割的剩余分区的大小)

#### 内存的回收

固定分区和动态分区方式都有不足之处。固定分区方式限制了活动进程的数目，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对以上两种内存方式的一种折衷方案。

在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。

## OS如何离散为程序分配内存空间？

连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的
大块空间，但须为之付出很大开销。如果允许将一个进程直接分散地装入到许多不相邻接的分区中，则无须再进行“紧凑”。**基于这一思想而产生了离散分配方式。**如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是段，则称为分段存储管理方式。

## 基本分页存储管理方式

分页存储是通过对内存划分，映射逻辑地址的内存后而进行的离散式的内存分配。

#### 页：进程中的块称为页或页面（逻辑划分）

 将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分 称为一个“页” 或“页面” 。 每个页面也有一个编号，即“页号” ， 页号也是从0 开始。 

<img :src="$withBase('/imags/1653957670057.png')" alt="1653957670057">

#### 页框：内存中的块称为页框（物理划分，页框号=页帧号=内存块号=物理块号=物理页号）

 将内存空间分为一个个大小相等的分区（比如:每个分区4KB),每个分区就是一个“页框” （页框=页帧=内存块=物理块=物理页面)。每个页框有一个编号,即“页框号”,页框号从0开始。 

<img :src="$withBase('/imags/1653957742604.png')" alt="1653957742604">

#### 页表：记录块和页的映射关系的表，每个进程都有自己的页表，页表通常在PCB进程控制块中

<img :src="$withBase('/imags/1653957818376.png')" alt="1653957818376">

#### 页表项

- 一个进程对应一张页表；
- 进程中的每个页面对应一个页表项；
- 每个页表项由“页号”和“块号“组成；
- 页表记录进程页面和实际存放的内存块之间的映射关系；
- 每个页表向项的长度是相同的；

#### 如何计算页表项

>  假设某系统物理内存大小为 4GB， 页面大小为 4KB， 则每个页表项至少应该为多少字节？ 

```shell
内存块大小=页面大小=4KB= 212B
4GB 的内存总共会被分为 232 / 212 = 220个内存块
内存块号的范围应该是 0 ~220 -1
内存块号至少要用 20 bit 来表示
至少要用3B(3个字节)来表示块号（3*8=24bit）
```

#### 如何进行逻辑地址到物理地址的转换

进程的各个页面是离散的，每个页面内部是连续存放的，因此需要知道页号和页内的页内偏移量

 如果要访问逻辑地址 A， 则

- 确定逻辑地址A 对应的“页号” P
- 找到P号页面在内存中的起始地址（需要查页表）
- 确定逻辑地址A 的“页内偏移量
  - 逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W 

```shell
页号 = 逻辑地址 / 页面长度（取整数部分）
页内偏移量 = 逻辑地址 % 页面长度（取余数部分）
逻辑地址可以拆分成页号、页内偏移量
通过查找页表，可知页面在内存中的起始地址。
物理地址（内存中的地址） = 页面在内存中的起始地址 + 页内偏移量
```

#### 地址变换机构

由于页表是存放在内存中的，这使 CPU 在每存取一个数据时，都要两次访问内存。第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量 W 拼接，以形成物理地址。

为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”(Associative Memory)，或称为“快表”，在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer)，用以存放当前访问的那些页表项。

##### 变换过程如下

<img :src="$withBase('/imags/1653958336010.png')" alt="1653958336010">

1. 在 CPU 给出有效地址后，由地址变换机构自动地将页号 P 送入高速缓冲寄存器
2. 将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中
3. 直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。
4. 如在块表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送地址寄存器
5. 同时，再将此页表项存入快表的一个寄存器单元中，即重新修改快表。
6. 如果联想寄存器已满，则 OS 必须找到一个老的且已被认为不再需要的页表项，将它换出

## 基本分段存储管理方式

### 为什么要引入分段存储管理方式

#### 方便编程

用户将自己的作业逻辑划分为若干个段，要访问的逻辑地址由段名和段内偏移量决定。

#### 信息共享

在实现对程序和数据的共享时，以信息的逻辑单位为基础，段是信息的逻辑单位，为了实现它的共享。

#### 信息保护

分段能够更有效方便的实现信息的保护功能

#### 动态增长

在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。而分段存储管理方式却能较好地解决这一问题。

### 什么是分段存储管理方式

- 程序通过分段划分为多个模块，每个段定义一组逻辑信息。如代码段（主程序段main，子程序段X）、数据段D、栈段S等。
- 每段有自己的名字（一般用段号做名），都从0编址，可分别编写和编译。
- 装入内存时，每段赋予各段一个段号。
- 每段占据一块连续的内存。（即有离散的分段，又有连续的内存使用）。各段大小不等。
- 地址结构：段号 + 段内地址 段表：记录每段实际存放的物理地址 

## 分页和分段有什么区别

- 标识单位
  - 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。
  - 段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。
- 地址划分
  - 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；
  - 段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。
- 地址空间
  - 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；
  - 分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址

## 虚拟存储器技术

### 问题引入

> 问题：无论是分段存储方式还是分页存储方式，都需要将作业全部装入内存才可以使用，这就导致了俩个问题
>
> > 作业很大时，由于内存容量不足，故而会有很多作业留在外存等待
> >
> > 大量作业执行时，只能分批次少量执行
>
> 解决：对于以上问题的解决方式
>
> > 物理上增加内存容量，但是这还是无法满足所有的作业要求，因为无法确定作业的大小
> >
> > 逻辑上扩充内存容量

### 什么是虚拟存储技术

虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。

其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。

### 虚拟存储技术的实现

#### 分页请求系统

- 请求分页的页表机制
- 缺页中断机制
- 地址变换机制
- 实现请求调页和页面置换

#### 分段请求系统

## 设备管理

### 什么是设备

设备管理的主要功能有: 缓冲区管理、设备分配、设备处理、虚拟设备及实现设备独立性等。

### 设备的分类

> 按设备使用特性
>
> > 1. 存储设备
> > 2. 输入输出设备（键盘、扫描仪等）
>
> 按传输速率分类
>
> > 1. 低速设备（键盘、鼠标等）
> > 2. 中速设备（有行式打印机、 激光打印机）
> > 3. 高速设备（磁盘机、光盘机）
>
> 按信息交换的单位分类
>
> > 1. 块设备，用于存储信息，由于西悉尼的存取以数据块为单位而得名，属于有结构设备，如磁盘
> > 2. 字符设备，用于数据的输入和输出，基本单位是字符，故称为字符设备
>
> 按设备的共享属性分类
>
> > 1. 独占设备，指一段时间内只允许一个用户访问的设备
> > 2. 共享设备，一段时间内允许多个进程访问的设备
> > 3. 虚拟设备，通过虚拟技术酱独占设备变为若干个逻辑设备

### 设备控制器及接口

#### 设备控制器

设备控制器是计算机中的一个实体，其主要职责是控制一个或多个 I/O 设备，以实现 I/O设备和计算机之间的数据交换。它是 CPU 与 I/O 设备之间的接口，它接收从 CPU 发来的命令，并去控制 I/O 设备工作。

#### 设备控制器的分类

- 控制字符设备的控制器
- 控制块设备的控制器

#### 设备控制器的基本功能

- 接收和识别命令
  - CPU可以向控制器发送多种不同的命令，设备控制器可以接收并识别这些命令
- 数据交换
  - 实现 CPU 与控制器之间、控制器与设备之间的数据交换
  - CPU与控制器，通过数据总线，由CPU并行地把数据写入控制器
  - 控制器与设备，将数据输入到控制器，或从控制器传送给设备
- 标识和报告设备的状态
- 地址识别
  - 系统中的每一个设备都有一个地址
- 数据缓冲
  - 由于 I/O 设备的速率较低而 CPU 和内存的速率却很高，故在控制器中必须设置一缓冲器
- 差错控制
  - 设备控制器还兼管对由 I/O 设备传送来的数据进行差错检测

#### 设备控制器的组成

![1654825744288](C:\Users\MSI\AppData\Roaming\Typora\typora-user-images\1654825744288.png)

设备并不是直接与 CPU 进行通信，而是与设备控制器通信，因此，在 I/O 设备中应含有与设备控制器间的接口。

![1654824255885](C:\Users\MSI\AppData\Roaming\Typora\typora-user-images\1654824255885.png)

- 数据信号线
  - 用于设备和设备控制器之间传递数据信号
  - 输入：先进入缓冲区，当达到一定的比特数后，进入设备控制器
  - 输出：从设备控制器经过数据信号线传来的一批数据先存在缓冲区，就转换器处理后，逐个字符的输出
- 控制信号线
  - 由设备控制器向 I/O 设备发送控制信号时的通路
  - 规定了设备将要执行的操作
- 状态信号线
  - 用于传送指示设备当前状态的信号
  - 设备读、设备写

## I/O通道

虽然在 CPU 与 I/O 设备之间增加了设备控制器后，已能大大减少 CPU 对 I/O 的干预，但当主机所配置的外设很多时，CPU 的负担仍然很重。

为此，在 CPU 和设备控制器之间又增设了通道。其主要目的是为了建立独立的 I/O 操作，不仅使数据的传送能独立于 CPU，而且也希望有关对 I/O 操作的组织、 管理及其结束处理尽量独立，以保证 CPU 有更多的时
间去进行数据处理。

在设置了通道后，CPU 只需向通道发送一条 I/O指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的 I/O 任务后，才向 CPU 发中断信号。

