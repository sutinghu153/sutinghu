{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{409:function(t,e,a){\"use strict\";a.r(e);var s=a(54),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"makefile\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#makefile\"}},[t._v(\"#\")]),t._v(\" Makefile\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"程序执行的一般过程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#程序执行的一般过程\"}},[t._v(\"#\")]),t._v(\" 程序执行的一般过程\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"编译\")]),t._v(\"：C 、C++ 源文件编译成中间代码文件——\"),a(\"strong\",[t._v(\".c .cpp\")]),t._v(\"文件\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"链接\")]),t._v(\"：将中间文件合成执行文件——\"),a(\"strong\",[t._v(\".o\")]),t._v(\"文件\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"打包\")]),t._v(\"：链接器只会查询方法、函数对应的目标文件，并不受源文件的影响。当源文件过多时，编译生成的中间目标文件太多，为了方便管理，需要给中间文件打包——\"),a(\"strong\",[t._v(\".a\")]),t._v(\"文件\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"about-makefile\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#about-makefile\"}},[t._v(\"#\")]),t._v(\" about Makefile\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"make\")]),t._v(\" 命令执行时，需要一个 \"),a(\"strong\",[t._v(\"Makefile\")]),t._v(\" 文件，以告诉 \"),a(\"strong\",[t._v(\"make\")]),t._v(\" 命令需要怎么样的去编译和链接程序。Makefile可以解决以下问题：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目标程。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，并链接目标程序。\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"makefile的规则\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#makefile的规则\"}},[t._v(\"#\")]),t._v(\" Makefile的规则\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-makefile extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-makefile\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token symbol\"}},[t._v(\"target ...\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" prerequisites ...\\ncommand\\n\")])])]),a(\"ul\",[a(\"li\",[t._v(\"target，目标文件，可以是objectfile 也可以是执行文件\")]),t._v(\" \"),a(\"li\",[t._v(\"prerequisites，依赖文件，即生成目标文件所需要的所有的文件或目标\")]),t._v(\" \"),a(\"li\",[t._v(\"command，make需要执行的命令，任意的shell命令\")])]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"target\")]),t._v(\" 这一个或多个的目标文件依赖于\"),a(\"strong\",[t._v(\"prerequisites\")]),t._v(\" 中的文件，其生成规则定义在 \"),a(\"strong\",[t._v(\"command\")]),t._v(\" 中\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-makefile extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-makefile\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token symbol\"}},[t._v(\"run\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" main.o hello.o test.o\\n    gcc -o run main.o hello.o test.o\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[t._v(\".PHONY\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" clean\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token symbol\"}},[t._v(\"clean\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\"\\n    -rm run *.o  \\n\")])])]),a(\"h2\",{attrs:{id:\"makefile的工作机制\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#makefile的工作机制\"}},[t._v(\"#\")]),t._v(\" Makefile的工作机制\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"make 会在\"),a(\"strong\",[t._v(\"当前目录下\")]),t._v(\"找名字叫“Makefile”或“makefile”的文件。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果找到，它会找文件中的\"),a(\"strong\",[t._v(\"第一个目标文件\")]),t._v(\"（target），并把这个文件作为最终的目标文件。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果 目标文件不存在，或是 目标文件 所依赖的后面的 .o 文件的文件修改时间要比 目标文件新，那么，他就会执行后面所定义的命令来生成目标文件。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果 目标文件所依赖的.o 文件也存在，那么 make 会在当前文件中找目标为.o 文件的依赖性，如果找到则再根据那一个规则生成.o 文件。（这有点像一个堆栈的过程）\")]),t._v(\" \"),a(\"li\",[t._v(\"当然，你的 C 文件和 H 文件是存在的啦，于是 make 会生成 .o 文件，然后再用 .o 文件生成执行文件。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"以上过程层层依赖，直到最终编译出第一个目标文件\")]),t._v(\" \"),a(\"p\",[t._v(\"规则的执行代码行要以   Tab   键作为开头\")]),t._v(\" \"),a(\"p\",[t._v(\"整个系统文件的Makefile的工作方式如下\")]),t._v(\" \"),a(\"p\",[t._v(\"1、读入所有的 Makefile。\")]),t._v(\" \"),a(\"p\",[t._v(\"2、读入被 include 的其它 Makefile。\")]),t._v(\" \"),a(\"p\",[t._v(\"3、初始化文件中的变量。\")]),t._v(\" \"),a(\"p\",[t._v(\"4、推导隐晦规则，并分析所有规则。\")]),t._v(\" \"),a(\"p\",[t._v(\"5、为所有的目标文件创建依赖关系链。\")]),t._v(\" \"),a(\"p\",[t._v(\"6、根据依赖关系，决定哪些目标要重新生成。\")]),t._v(\" \"),a(\"p\",[t._v(\"7、执行生成命令。\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"makefile中的变量\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#makefile中的变量\"}},[t._v(\"#\")]),t._v(\" Makefile中的变量\")]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"$(变量名)\")]),t._v(\" 采用该方式来表示Makefile文件中的所有字符串变量。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"引用其它的makefile文件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#引用其它的makefile文件\"}},[t._v(\"#\")]),t._v(\" 引用其它的Makefile文件\")]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"include <filename>\")]),t._v(\" 用来包含其它Makefile文件\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"优先在当前目录搜索\")]),t._v(\" \"),a(\"li\",[t._v(\"其次如果使用\"),a(\"strong\",[t._v(\"make -I\")]),t._v(\" 路径 或者 \"),a(\"strong\",[t._v(\"make --include-dir\")]),t._v(\" 路径，会在参数指定的位置搜索\")]),t._v(\" \"),a(\"li\",[t._v(\"最后默认路径**（/usr/local/bin或者/usr/include）**中搜索\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language-makefile extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-makefile\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"include\")]),t._v(\" Makefile.hello\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token symbol\"}},[t._v(\"run\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" main.o hello.o test.o\\n    gcc -o run main.o hello.o test.o\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[t._v(\".PHONY\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" clean\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token symbol\"}},[t._v(\"clean\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\"\\n    -rm run *.o  \\n\")])])]),a(\"p\",[t._v(\"如果打算无法找到Makefile.hello文件也要进行执行下去，只需在include前加个减号\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-makefile extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-makefile\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"-include\")]),t._v(\" Makefile.hello\\n\")])])]),a(\"h2\",{attrs:{id:\"环境变量-makefiles\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#环境变量-makefiles\"}},[t._v(\"#\")]),t._v(\" 环境变量 MAKEFILES\")]),t._v(\" \"),a(\"p\",[t._v(\"为了方便管理环境变量及当前的目录，即方便\"),a(\"code\",[t._v(\"include\")]),t._v(\"命令的使用，可以使用环境变量。类似于全局变量、宏。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[t._v(\"需要在当前环境中进行定义\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"所有的Makefile都将受影响\")])])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"makefile中的运算符\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#makefile中的运算符\"}},[t._v(\"#\")]),t._v(\" Makefile中的运算符\")]),t._v(\" \"),a(\"p\",[t._v(\"通配符用来处理一系列类似或相似的文件。\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"符号\")]),t._v(\" \"),a(\"th\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"含义\")]),t._v(\" \"),a(\"th\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"例子\")]),t._v(\" \"),a(\"th\",[t._v(\"释义\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"*\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"代表类似的文件\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"*.c\")]),t._v(\" \"),a(\"td\",[t._v(\"代表以.c结尾的文件\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"~\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"指向某个用户\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"~/test\")]),t._v(\" \"),a(\"td\",[t._v(\"表示当前用户的$HOME 目录下的 test 目录\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"~\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"指向某个用户\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"~sutinghu/test\")]),t._v(\" \"),a(\"td\",[t._v(\"表示sutinghu用户空间下的test目录\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"$()\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"占位符\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"name = $(sutinghu)\")]),t._v(\" \"),a(\"td\",[t._v(\"实际使用过程中，将i替换为sutinghu\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\":=\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"限定赋值符\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"name := $(sutinghu)\")]),t._v(\" \"),a(\"td\",[t._v(\"实际过程中，name所取变量为sutinghu，无论后面是否有其它赋值操作\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"=\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"赋值符\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"name = sutinghu\")]),t._v(\" \"),a(\"td\",[t._v(\"将name的值赋值为sutinghu\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"?=\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"判断赋值符\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"name?=sutinghu\")]),t._v(\" \"),a(\"td\",[t._v(\"如果name前面没有被赋值，那么该变量就是sutinghu，如果前面已经被赋值过，就使用前面的值\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"+=\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"变量追加\")]),t._v(\" \"),a(\"td\",{staticStyle:{\"text-align\":\"center\"}},[t._v(\"objects = main.o inpiut.o，objects += calcu.o\")]),t._v(\" \"),a(\"td\",[t._v(\"一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此变量 objects 变成了“main.o input.o calcu.o”\")])])])]),t._v(\" \"),a(\"div\",{staticClass:\"language-makefile extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-makefile\"}},[a(\"code\",[t._v(\"objects \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[t._v(\"$\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"main.o hello.o test.o\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token symbol\"}},[t._v(\"run\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" \\n    gcc -o run main.o hello.o test.o\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[t._v(\".PHONY\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\" clean\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token symbol\"}},[t._v(\"clean\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\"\\n    -rm run *.o  \\n\")])])]),a(\"h2\",{attrs:{id:\"makefile中的文件搜索\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#makefile中的文件搜索\"}},[t._v(\"#\")]),t._v(\" Makefile中的文件搜索\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"VPATH\\n\"),a(\"ul\",[a(\"li\",[t._v(\"如果没有指明这个变量，make 只会在当前的目录中去找寻依赖文件和目标文件。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了\")])])])]),t._v(\" \"),a(\"div\",{staticClass:\"language-makefile extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-makefile\"}},[a(\"code\",[t._v(\"VPATH \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" src\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\":\")]),t._v(\"../headers \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"#make 会按照这个顺序进行搜索\")]),t._v(\"\\n\")])])]),a(\"ul\",[a(\"li\",[t._v(\"vpath\\n\"),a(\"ul\",[a(\"li\",[t._v(\"vpath   \"),a(\"em\",[a(\"strong\",[t._v(\"pattern   directories\")])]),t._v(\" 为符合模式 \"),a(\"em\",[a(\"strong\",[t._v(\"pattern\")])]),t._v(\" 的文件指定搜索目录 \"),a(\"em\",[a(\"strong\",[t._v(\"directories\")])]),t._v(\" 。\")]),t._v(\" \"),a(\"li\",[t._v(\"vpath \"),a(\"em\",[a(\"strong\",[t._v(\"pattern\")])]),t._v(\"\\n清除符合模式 \"),a(\"em\",[a(\"strong\",[t._v(\"pattern\")])]),t._v(\" 的文件的搜索目录。\")]),t._v(\" \"),a(\"li\",[t._v(\"vpath\\n清除所有已被设置好了的文件搜索目录。\")])])])]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"vapth 使用方法中的 \"),a(\"em\",[a(\"strong\",[t._v(\"pattern\")])]),t._v(\" 需要包含 \"),a(\"em\",[a(\"strong\",[t._v(\"“%”\")])]),t._v(\" 字符。\")]),t._v(\" \"),a(\"li\",[a(\"em\",[a(\"strong\",[t._v(\"“%”\")])]),t._v(\" 的意思是匹配零或若干字符，例如， \"),a(\"em\",[a(\"strong\",[t._v(\"“%.h”\")])]),t._v(\" 表示所有以 \"),a(\"em\",[a(\"strong\",[t._v(\"“.h”\")])]),t._v(\" 结尾的文件。\")]),t._v(\" \"),a(\"li\",[a(\"em\",[a(\"strong\",[t._v(\"pattern\")])]),t._v(\" 指定了要搜索的文件集.\")]),t._v(\" \"),a(\"li\",[a(\"em\",[a(\"strong\",[t._v(\"directories\")])]),t._v(\" 则指定了 \"),a(\"em\",[a(\"strong\",[t._v(\"pattern\")])]),t._v(\" 的文件集的搜索的目录。\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language-makefile extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-makefile\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"#  make 在“../headers”目录下搜索所有以“.h”结尾的文件。\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"vpath\")]),t._v(\" %.h ../headers\\n\")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);","extractedComments":[]}